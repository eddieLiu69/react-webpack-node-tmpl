import * as React from 'react';
import { fetchComments } from '../actions/comments'
// import * as marked from 'marked';

// import * as $ from 'zepto-modules';
// var $: ZeptoStatic = require('zepto-modules');

interface ICommentProps extends React.Props<any>, React.HTMLAttributes {
    key: number;
    author: string;
    text?: string;
}

class CommentForm extends React.Component<{ onCommentSubmit: (comment: { author: string, text: string }) => void }, any> {
    constructor(props) {
        super(props);
        this.state = { author: '', text: '' };
    }

    handleAuthorChange = (e) => this.setState({ author: e.target.value });

    handleTextChange = (e) => this.setState({ text: e.target.value });

    handleSubmit = (e) => {
        e.preventDefault();
        var author = this.state.author.trim();
        var text = this.state.text.trim();
        if (!text || !author) {
            return;
        }

        this.props.onCommentSubmit({ author: author, text: text });

        this.setState({ author: '', text: '' });
    };

    render() {
        return (
            <form className="commentForm" onSubmit={this.handleSubmit}>
                <input
                    type="text"
                    placeholder="Your name"
                    value={this.state.author}
                    onChange={this.handleAuthorChange}
                    />
                <input
                    type="text"
                    placeholder="Say something..."
                    value={this.state.text}
                    onChange={this.handleTextChange}
                    />
                <input type="submit" value="Post" />
                </form>
        );
    }
}

class Comment extends React.Component<ICommentProps, any> {
    rawMarkup(raw) {
        // var rawMarkup = marked(raw, { sanitize: true });
        return { __html: raw };
    }

    render() {
        return (
            <div className="comment" >
                <h2 className="commentAuthor" >
                    { this.props.author }
                    </h2>
                <span dangerouslySetInnerHTML={ this.rawMarkup(this.props.text) } />
                </div>
        );
    }
}

class CommentList extends React.Component<{ data: ICommentProps[] }, any> {
    render() {
        var nodes = this.props.data.map((comment) => <Comment author={comment.author} key={comment.key} text={comment.text} />);
        return (<div className="commentList">{nodes}</div>);
    }
}

var data: ICommentProps[] = [
    { key: 1, author: "Pete Hunt", text: "This is one comment" },
    { key: 2, author: "Jordan Walke", text: "This is *another* comment" }
];

class CommentBox extends React.Component<{ url: string }, any> {
    constructor(props) {
        super(props);
        this.state = { data: [], url: this.props.url || '/api/comments' };
    }

    loadCommentsFromServer() {
        fetchComments().promise.then((resp) => {
            this.setState({ data: resp.data })
            return resp.data;
        }).catch((err) => {
            console.log("oops!" + err);
        });
    }

    handleCommentSubmit = (comment) => {
        // TODO: submit to the server and refresh the list
        console.log('handleCommentSubmit' + JSON.stringify(comment));

        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.key = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({ data: newComments });

        var req = new XMLHttpRequest();
        req.open('POST', this.state.url, true);
        req.setRequestHeader('Content-Type', 'application/json; charset=utf-8');
        req.onload = () => {
            if (req.status >= 200 && req.status < 400) {
                // Success!
                var resp = req.responseText;
                this.setState({ data: JSON.parse(resp) });
            } else {
                // We reached our target server, but it returned an error
                this.setState({ data: comments });
            }
        };
        req.onerror = () => {
            this.setState({ data: comments });
        };

        req.send(JSON.stringify(comment));
    };

    componentDidMount() {
        this.loadCommentsFromServer();
        // setInterval(this.loadCommentsFromServer, 500);
    }

    render() {
        return (
            <div className="commentBox" >
                <h1>Comments</h1>
                <CommentList data={ this.state.data } />
                <CommentForm onCommentSubmit={this.handleCommentSubmit} />
                </div>
        );
    }
}
export default CommentBox;